import encoding
from logger import Logger
import io 
import abc

import tensorflow as tf
import tensorflow_quantum as tfq

import cirq
import cirq.contrib.svg


import sympy
import numpy as np

import matplotlib.pyplot as plt
import time

class Model(abc.ABC):
    """ Abstract class that wraps a tf.keras.Model, encoding and plugging in the image data. """
    def __init__(self, x_train, y_train, x_test, y_test, epochs=10, batch_size=128):
        # Encode the inputs
        Logger.log(f"============================================ {self.__class__.__name__} ============================================")
        
        encoder = self._make_encoder()
        (self.x_train, self.y_train), (self.x_test,
                                       self.y_test) = encoder.encode_dataset(
                                           x_train, y_train, x_test, y_test)

        self.epochs = epochs
        self.batch_size = batch_size    
        # Will store history for the option to plot
        self.history = None

        # Compile the model
        self.model = self._make_model()
        self.model.compile(
            optimizer=tf.keras.optimizers.Adam(learning_rate=0.02),
            loss=tf.keras.losses.mse,
            metrics=[self._get_accuracy()])
        
        # Redirect summary output to a string buffer
        summary_str = io.StringIO()
        self.model.summary(print_fn=lambda x: summary_str.write(x + "\n"))
        
        # Log the model summary
        Logger.log(summary_str.getvalue())
        
        self.time = None


    @abc.abstractmethod
    def _make_encoder(self) -> encoding.ImageEncoder:
        """ Creates an encoder to encode the input images """
        pass


    @abc.abstractmethod
    def _make_model(self) -> tf.keras.Model:
        """ Builds an uncompiled model for image classification """
        pass


    @abc.abstractmethod
    def _get_accuracy(self):
        """ Returns the accuracy function for model fitting """
        pass


    def train(self):
        start_time = time.time()
        """ Trains the model with the encoded data """
        self.history = self.model.fit(x=self.x_train,
                                      y=self.y_train,
                                      batch_size=self.batch_size,
                                      epochs=self.epochs,
                                      verbose=1,
                                      validation_data=(self.x_test,
                                                       self.y_test))
        self.time = time.time() - start_time
        Logger.log(self.history.history)
        Logger.log(f"Training completed {self.__class__.__name__} in {self.time:.2f} seconds")


    def plot(self):
        """ Plots accuracy as a function of epochs. Must first run train() """
        plt.figure()
        plt.plot(self.history.history["accuracy"][1:], label="Training")
        plt.plot(self.history.history["val_accuracy"][1:], label="Test")
        plt.title("%s accuracy" % self.__class__.__name__)
        plt.xlabel("Epochs")
        plt.ylabel("Loss")
        plt.legend()
        file_path = f"outputs/{self.__class__.__name__}_{self.epochs}_{self.batch_size}.png"
        plt.savefig(file_path)
        Logger.log(f"Plot saved to {file_path}")
        
        
    def save_model(self, filepath=None):
        """ Saves the trained model to a specified file path """
        if not self.model:
            raise ValueError("The model has not been created yet.")
        if filepath is None:
            filepath=f"outputs/{self.__class__.__name__}_{self.epochs}_{self.batch_size}.keras"
            self.model.save(filepath)
        else:
            self.model.save(filepath)
        Logger.log(f"Model saved at {filepath}")
    


class QuantumCnn(Model):
    """ Quantum CNN to classify images. """

    CONVOLUTION_PARAMS = 15
    POOL_PARAMS = 6
    # Number of tunable parameters per convolution and pool layer
    PARAMS_PER_LAYER = CONVOLUTION_PARAMS + POOL_PARAMS
    # Number of QCNN iterations
    NUM_LAYERS = int(np.log2(encoding.QuantumImageEncoder.NUM_QUBITS))
    # Total number of tunable paramters
    NUM_PARAMS = PARAMS_PER_LAYER * NUM_LAYERS

    def display_circuit(self, method_name, *args, **kwargs):
        """
        Display the circuit generated by a specified method.

        Args:
            method_name (str): The name of the method to generate the circuit.
            *args: Positional arguments to pass to the method.
            **kwargs: Keyword arguments to pass to the method.

        Returns:
            None: Displays the circuit using cirq's text diagram.
        """
        if hasattr(self, method_name):
            method = getattr(self, method_name)
            if callable(method):
                circuit = method(*args, **kwargs)
                if isinstance(circuit, cirq.Circuit):
                    print(circuit)
                else:
                    print(f"The method {method_name} did not return a cirq.Circuit.")
            else:
                print(f"The attribute {method_name} is not callable.")
        else:
            print(f"The method {method_name} does not exist in this class.")
        
    def _make_encoder(self) -> encoding.ImageEncoder:
        return encoding.QuantumImageEncoder()

    def _one_qubit_unitary(self, q, symbols):
        # Rotating qubit about all 3 axes by symbol values
        return cirq.Circuit(
            cirq.X(q)**symbols[0],
            cirq.Y(q)**symbols[1],
            cirq.Z(q)**symbols[2])

    def _two_qubit_unitary(self, q1, q2, symbols):
        # Rotating both qubits about all 3 axes by symbol values
        circ = cirq.Circuit()
        circ += self._one_qubit_unitary(q1, symbols[:3])
        circ += self._one_qubit_unitary(q2, symbols[3:6])

        circ += cirq.ZZ(q1, q2)**symbols[6]
        circ += cirq.YY(q1, q2)**symbols[7]
        circ += cirq.XX(q1, q2)**symbols[8]

        circ += self._one_qubit_unitary(q1, symbols[9:12])
        circ += self._one_qubit_unitary(q2, symbols[12:])

        return circ

    def _two_qubit_pool(self, source, sink, symbols):
        # Do a pooling operation, reducing the entanglement from 2 qubits to 1
        circ = cirq.Circuit()

        sink_circ = self._one_qubit_unitary(sink, symbols[:3])
        source_circ = self._one_qubit_unitary(source, symbols[3:6])

        circ += sink_circ
        circ += source_circ
        circ += cirq.CX(source, sink)
        circ += sink_circ**-1

        return circ

    def _convolution_circuit(self, qubits, symbols):
        # Cascade of 2 qubit unitaries on all pairs of qubits
        circ = cirq.Circuit()
        for i in range(0, len(qubits) - 1, 2):
            circ += self._two_qubit_unitary(qubits[i], qubits[i + 1], symbols)

        for i in range(1, len(qubits), 2):
            j = (0 if i == len(qubits) - 1 else i + 1)
            circ += self._two_qubit_unitary(qubits[i], qubits[j], symbols)

        return circ

    def _pool_circuit(self, source_qubits, sink_qubits, symbols):
        # Pool information from two qubits into one
        circ = cirq.Circuit()
        for source, sink in zip(source_qubits, sink_qubits):
            circ += self._two_qubit_pool(source, sink, symbols)
        return circ

    def _make_model_circ(self, qubits):
        # Alternating convolution and pooling layers
        circ = cirq.Circuit()

        symbols = sympy.symbols("qconv0:%d" % QuantumCnn.NUM_PARAMS)

        # Offset into how many qubits have been destroyed by pooling
        qubit_offset = 0
        symbol_index = 0

        for i in range(QuantumCnn.NUM_LAYERS):
            # Apply convolution to qubits
            circ += self._convolution_circuit(
                qubits[qubit_offset:], symbols[symbol_index:symbol_index +
                                               QuantumCnn.CONVOLUTION_PARAMS])
            symbol_index += QuantumCnn.CONVOLUTION_PARAMS

            # Numer of qubits left
            num_qubits = encoding.QuantumImageEncoder.NUM_QUBITS - qubit_offset
            # Split between pooled qubits
            split_index = qubit_offset + num_qubits // 2
            # Pool first and second half of qubits
            circ += self._pool_circuit(
                qubits[qubit_offset:split_index], qubits[split_index:],
                symbols[symbol_index:symbol_index + QuantumCnn.POOL_PARAMS])
            symbol_index += QuantumCnn.POOL_PARAMS

            qubit_offset += num_qubits // 2

        assert qubit_offset == encoding.QuantumImageEncoder.NUM_QUBITS - 1

        return circ

    def _cluster_circuit(self, qubits):
        # Entangle all the qubits together
        circ = cirq.Circuit(cirq.H.on_each(qubits))
        for i in range(len(qubits)):
            j = (0 if i == len(qubits) - 1 else i + 1)
            circ += (cirq.CZ(qubits[i], qubits[j]))
        return circ

    def _make_model(self) -> tf.keras.Model:
        cluster = cirq.GridQubit.rect(1,
                                      encoding.QuantumImageEncoder.NUM_QUBITS)
        # Use the Z gate for readout
        operator = cirq.Z(cluster[-1])

        model_input = tf.keras.Input(shape=(), dtype=tf.dtypes.string)
        cluster_circ = tfq.layers.AddCircuit()(
            model_input, prepend=self._cluster_circuit(cluster))

        pqc = tfq.layers.PQC(self._make_model_circ(cluster),
                             operator)(cluster_circ)
        return tf.keras.Model(inputs=[model_input], outputs=[pqc])

    @tf.function
    def accuracy(self, y_actual, y_pred):
        # Custom accuracy mapping outputs to a boolean
        y_actual = tf.squeeze(y_actual)
        y_pred = tf.map_fn(lambda y: 1.0 if y >= 0.5 else 0.0, y_pred)
        return tf.keras.backend.mean(tf.keras.backend.equal(y_actual, y_pred))

    def _get_accuracy(self):
        return self.accuracy


class ClassicalNn(Model):
    """ A "fair" classical NN with around the same number of parameters as the quantum one,
        used to evaluate the QCNN.
        This has 91 parameters while the QCNN 84. """
    def _make_encoder(self) -> encoding.ImageEncoder:
        return encoding.ImageEncoder()

    def _make_model(self) -> tf.keras.Model:
        return tf.keras.models.Sequential([
            tf.keras.layers.Flatten(input_shape=(4, 4, 1)),
            tf.keras.layers.Dense(5, activation="relu"),
            tf.keras.layers.Dense(1)
        ])

    def _get_accuracy(self):
        return "accuracy"
    
if __name__ == '__main__':
    (x_train, y_train), (x_test, y_test) = tf.keras.datasets.mnist.load_data()
    x_train = x_train[:50]
    y_train = y_train[:50]
    x_test = x_test[:50]
    y_test = y_test[:50]
    EPOCHS = 5
    qubits = [cirq.GridQubit(0, i) for i in range(16)]  # Tạo 4 qubit
    symbols = [sympy.Symbol(f's{i}') for i in range(88)]  # Tạo 15 tham số
    qcnn = QuantumCnn(x_train, y_train, x_test, y_test)
    qcnn.display_circuit('_convolution_circuit', qubits, symbols)
